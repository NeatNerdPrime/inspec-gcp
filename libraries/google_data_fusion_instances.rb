# frozen_string_literal: false

# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
#
# ----------------------------------------------------------------------------
#
#     This file is automatically generated by Magic Modules and manual
#     changes will be clobbered when the file is regenerated.
#
#     Please read more about how to change this file in README.md and
#     CONTRIBUTING.md located at the root of this package.
#
# ----------------------------------------------------------------------------
require 'gcp_backend'
class DataFusionInstances < GcpResourceBase
  name 'google_data_fusion_instances'
  desc 'Instance plural resource'
  supports platform: 'gcp'

  attr_reader :table

  filter_table_config = FilterTable.create

  filter_table_config.add(:names, field: :name)
  filter_table_config.add(:descriptions, field: :description)
  filter_table_config.add(:types, field: :type)
  filter_table_config.add(:enable_stackdriver_loggings, field: :enable_stackdriver_logging)
  filter_table_config.add(:enable_stackdriver_monitorings, field: :enable_stackdriver_monitoring)
  filter_table_config.add(:private_instances, field: :private_instance)
  filter_table_config.add(:network_configs, field: :network_config)
  filter_table_config.add(:labels, field: :labels)
  filter_table_config.add(:options, field: :options)
  filter_table_config.add(:create_times, field: :create_time)
  filter_table_config.add(:update_times, field: :update_time)
  filter_table_config.add(:states, field: :state)
  filter_table_config.add(:state_messages, field: :state_message)
  filter_table_config.add(:service_endpoints, field: :service_endpoint)
  filter_table_config.add(:zones, field: :zone)
  filter_table_config.add(:versions, field: :version)
  filter_table_config.add(:service_accounts, field: :service_account)
  filter_table_config.add(:display_names, field: :display_name)
  filter_table_config.add(:available_versions, field: :available_version)
  filter_table_config.add(:api_endpoints, field: :api_endpoint)
  filter_table_config.add(:gcs_buckets, field: :gcs_bucket)
  filter_table_config.add(:accelerators, field: :accelerators)
  filter_table_config.add(:p4_service_accounts, field: :p4_service_account)
  filter_table_config.add(:tenant_project_ids, field: :tenant_project_id)
  filter_table_config.add(:dataproc_service_accounts, field: :dataproc_service_account)
  filter_table_config.add(:enable_rbacs, field: :enable_rbac)
  filter_table_config.add(:crypto_key_configs, field: :crypto_key_config)
  filter_table_config.add(:disabled_reasons, field: :disabled_reason)
  filter_table_config.add(:event_publish_configs, field: :event_publish_config)
  filter_table_config.add(:enable_zone_separations, field: :enable_zone_separation)
  filter_table_config.add(:satisfies_pzs, field: :satisfies_pzs)
  filter_table_config.add(:workforce_identity_service_endpoints, field: :workforce_identity_service_endpoint)
  filter_table_config.add(:patch_revisions, field: :patch_revision)
  filter_table_config.add(:dataplex_data_lineage_integration_enableds, field: :dataplex_data_lineage_integration_enabled)
  filter_table_config.add(:maintenance_policies, field: :maintenance_policy)

  filter_table_config.connect(self, :table)

  def initialize(params = {})
    super(params.merge({ use_http_transport: true }))
    @params = params
    @table = fetch_wrapped_resource('instances')
  end

  def fetch_wrapped_resource(wrap_path)
    # fetch_resource returns an array of responses (to handle pagination)
    result = @connection.fetch_all(product_url, resource_base_url, @params, 'Get')
    return if result.nil?

    # Conversion of string -> object hash to symbol -> object hash that InSpec needs
    converted = []
    result.each do |response|
      next if response.nil? || !response.key?(wrap_path)
      response[wrap_path].each do |hash|
        hash_with_symbols = {}
        hash.each_key do |key|
          name, value = transform(key, hash)
          hash_with_symbols[name] = value
        end
        converted.push(hash_with_symbols)
      end
    end

    converted
  end

  def transform(key, value)
    return transformers[key].call(value) if transformers.key?(key)

    [key.to_sym, value]
  end

  def transformers
    {
      'name' => ->(obj) { [:name, obj['name']] },
      'description' => ->(obj) { [:description, obj['description']] },
      'type' => ->(obj) { [:type, obj['type']] },
      'enableStackdriverLogging' => ->(obj) { [:enable_stackdriver_logging, obj['enableStackdriverLogging']] },
      'enableStackdriverMonitoring' => ->(obj) { [:enable_stackdriver_monitoring, obj['enableStackdriverMonitoring']] },
      'privateInstance' => ->(obj) { [:private_instance, obj['privateInstance']] },
      'networkConfig' => ->(obj) { [:network_config, GoogleInSpec::DataFusion::Property::InstanceNetworkConfig.new(obj['networkConfig'], to_s)] },
      'labels' => ->(obj) { [:labels, GoogleInSpec::DataFusion::Property::InstanceLabels.new(obj['labels'], to_s)] },
      'options' => ->(obj) { [:options, GoogleInSpec::DataFusion::Property::InstanceOptions.new(obj['options'], to_s)] },
      'createTime' => ->(obj) { [:create_time, obj['createTime']] },
      'updateTime' => ->(obj) { [:update_time, obj['updateTime']] },
      'state' => ->(obj) { [:state, obj['state']] },
      'stateMessage' => ->(obj) { [:state_message, obj['stateMessage']] },
      'serviceEndpoint' => ->(obj) { [:service_endpoint, obj['serviceEndpoint']] },
      'zone' => ->(obj) { [:zone, obj['zone']] },
      'version' => ->(obj) { [:version, obj['version']] },
      'serviceAccount' => ->(obj) { [:service_account, obj['serviceAccount']] },
      'displayName' => ->(obj) { [:display_name, obj['displayName']] },
      'availableVersion' => ->(obj) { [:available_version, GoogleInSpec::DataFusion::Property::InstanceAvailableVersionArray.parse(obj['availableVersion'], to_s)] },
      'apiEndpoint' => ->(obj) { [:api_endpoint, obj['apiEndpoint']] },
      'gcsBucket' => ->(obj) { [:gcs_bucket, obj['gcsBucket']] },
      'accelerators' => ->(obj) { [:accelerators, GoogleInSpec::DataFusion::Property::InstanceAcceleratorsArray.parse(obj['accelerators'], to_s)] },
      'p4ServiceAccount' => ->(obj) { [:p4_service_account, obj['p4ServiceAccount']] },
      'tenantProjectId' => ->(obj) { [:tenant_project_id, obj['tenantProjectId']] },
      'dataprocServiceAccount' => ->(obj) { [:dataproc_service_account, obj['dataprocServiceAccount']] },
      'enableRbac' => ->(obj) { [:enable_rbac, obj['enableRbac']] },
      'cryptoKeyConfig' => ->(obj) { [:crypto_key_config, GoogleInSpec::DataFusion::Property::InstanceCryptoKeyConfig.new(obj['cryptoKeyConfig'], to_s)] },
      'disabledReason' => ->(obj) { [:disabled_reason, obj['disabledReason']] },
      'eventPublishConfig' => ->(obj) { [:event_publish_config, GoogleInSpec::DataFusion::Property::InstanceEventPublishConfig.new(obj['eventPublishConfig'], to_s)] },
      'enableZoneSeparation' => ->(obj) { [:enable_zone_separation, obj['enableZoneSeparation']] },
      'satisfiesPzs' => ->(obj) { [:satisfies_pzs, obj['satisfiesPzs']] },
      'workforceIdentityServiceEndpoint' => ->(obj) { [:workforce_identity_service_endpoint, obj['workforceIdentityServiceEndpoint']] },
      'patchRevision' => ->(obj) { [:patch_revision, obj['patchRevision']] },
      'dataplexDataLineageIntegrationEnabled' => ->(obj) { [:dataplex_data_lineage_integration_enabled, obj['dataplexDataLineageIntegrationEnabled']] },
      'maintenancePolicy' => ->(obj) { [:maintenance_policy, GoogleInSpec::DataFusion::Property::InstanceMaintenancePolicy.new(obj['maintenancePolicy'], to_s)] },
    }
  end

  private

  def product_url(_ = nil)
    'https://datafusion.googleapis.com/v1/'
  end

  def resource_base_url
    '{{+parent}}/instances'
  end
end
